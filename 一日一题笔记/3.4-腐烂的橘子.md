这个问题类似于岛屿问题，我们只需将所有的烂橘子的坐标存放到一个队列里面，然后通过BFS将附近的新鲜橘子腐蚀即可。要求得最小分钟数，一分钟就是四个方向可以放的放入队列的一次。

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        r, c =len(grid), len(grid[0])
        d = [0, 1, 0, -1, 0]
        q = []
        step = cnt = 0

for i in range(r):
        for j in range(c):
            if grid[i][j] == 2: q.append([i, j])
            if grid[i][j] == 1: cnt += 1
                
    while q:
        if cnt == 0: return step
        
        n = len(q)
        for _ in range(n):
            x, y = q.pop(0)
            for i in range(4):
                nx, ny = x + d[i], y + d[i + 1]
                if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] == 1:
                    cnt -= 1
                    q.append([nx, ny])
                    grid[nx][ny] = 2
        step += 1
        
    return step if cnt == 0 else -1
```
有了计算最短路径的层序 BFS 代码框架，写这道题就很简单了。这道题的主要思路是：

1. 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。
2. 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。
3. 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。
4. 如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。

